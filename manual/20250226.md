## JSX와 스타일링

JSX : 자바스크립트를 위한 확장 문법. 리액트에서 JSX를 반드시
이용해야 하는 것은 아니지만 개발을 더 쉽게 만들어주는 이점이 있기
때문에 장기적으로 익히는게 이롭습니다.

예를 들어, JSX는 모든 값이 렌더링 되기 전에 JSX에서
이스케이프되므로 주입(Injection) 공격을 방지할 수 있음.
중괄호를 통해 자바스크립트 표현식을 감싸서 JSX에 포함시킬 수 있다는 점.

### props 

: 속성(Properties)의 축약어로, 상위 컴포넌트에서 하위 컴포넌트로
데이터를 전달하는데 사용되는 방식(React의 특징 어제
학습했습니다). 상위 컴포넌트는 하위 컴포넌트를 호출할 때, 해당 컴포ㅓㄴ트에 필요한 데이터를 props를 통해서 전달합니다. 이 데이터는__'키 - 값 쌍'__으로 구성되며, 다양한 자료형을 포함할 수
있습니다. 하위 컴포넌트는 props를 받아와 컴포넌트 내부에서 사용합니다(마치 매개변수처럼 사용한다는 
의미가 됩니다). props는 함수 매개변수처럼 컴포넌트 함수의 argument로 전달되며, 컴포넌트 내부에서 props를 참조하여 데이터를 사용합니다


#### props 예시 코드
```jsx
// 상위 컴포넌트
function ParentComponent(){
  return(
    <ChildComponent
      name="John"
      message="Hello from Parent"
    />
  );
}

//하위 컴포넌트
function ChildComponent(props){
  return(
    <div>
      <h2> {props.name}</h2>
      <p>{props.message}</p>
    </div>
  );
}
```

### State

: state는 리액트에서 사용하는 일반 자바스크립트 객체이며 렌더링 결과물에 영향을 주는 데이터를 가지고 있으며, 함수 내에서 선언된 state는 각 컴포넌트 안에서 관리합니다.

state는 onClick 같은 사용자 이벤트 또는 '네트워크 상태에 따라 변경'될 수 있습니다.
컴포넌트가 마운트(추후 수업)될 때 state의 기본 값으로 시작하고, 컴포넌트에서 자체적으로 state를 관리하지만 초기 상태를 설정하는 것 말고는 하위 컴포넌트의 state를 변경할 수 있는 권한이 없습니다.

즉, state는 하위 컴포넌트에서 직접 변경하는 것은 권장되지 않고, 만약 state의 값을 변경해야 한다면 해당 컴포넌트 내부에서 setState()를 사용해야 합니다.(추후 수업 예정)

- 리액트에서 컴포넌트 상태(State)는 시간의 변화에 따라 변경될 수 있는 정보를 보관하는 내부데이터 저장소에 해당함. 컴포넌트의 렌도링에도 영향을 줍니다.

- 상태가 업데이트되면(상태값이 바뀌면) 리액트는 컴포넌트의 리렌더링을 시도합니다(변경사항이 생길 때마다 자기가 알아서 업데이트를 해줬으니까요). 컴포넌트의 리렌더링이 끝나게 되면 상태는 최신 값을 유지하게 되는데, 이러한 특성으로 컴포넌트가 사용자 상호작용이나 기타 이벤트에 '동적'으로 반응할 수 있도록 해줍니다다

* 주의 사항 :
- 일반적으로 리액트 컴포넌트에 불필요한 상태를 도입하지 않는 것이 좋다

-> 불필요한 상태가 컴포넌트의 내부 로직의 복잡성을 증가시키기 때문에 예상치 못한 에러 발생

-> 그런 경우 지역 변수를 도입하는것이 대안이 될 수는 있습니다.

-> 근데 지역변수의 변경은 컴포넌트의 리렌더링을 만들지 않습니다.

-> 그렇다고 해서 강제로 리렌더링을 유도하면 지역 변수는 초기값으로 바뀌겠죠.

상태는 useState 훅 함수를 이용하여 만들 수 있다(훅 함수 개념은 아마 내일 쯤 수업 예정), 해당 함수는 상태의 초기값인 argument를 하나 받고 두 요소로 구성된 '배열'을 반환한다.
첫 번째 argument는 상태의 이름
두 번재 argument는 상태 값을 업데이트하는데 이용되는 함수에 해당함.

형식 : 

```jsx
const [state,setState] = React.useState(intialValue)
```

예를 들어 상태의 이름이 name이고, 초기값이 Robert인 상태 변수를 생성한다면

```jsx
cosnt [name,setName] = React.useState('Robert');
```

위의 형식과 예제를 비교하여 useState()함수를 사용하는데 익숙해지시면 좋겠습니다.

근데 매번 React.을 쓰는게 번거로운 경우에 미리 import를 시키는 방법이 있는데

```jsx
import React, {useState} from 'react';

cosnt [name,setName] = useState('Robert');

// name 속성의 속성값을 바꾸고 싶다면 
setName('Rob');

name ='Ray'; // 직접 바꾸는 방식이 있을 수 있는데
// 이상의 경우 UI 리렌더링이 일어나지 않습니다.
```

// import { useState } from "react";

// function App3(){
//   const [name,setName] = useState({
//     firstName : '크리스',
//     lastName : '에반스'
//   })
//   return(<div>안녕 {name.firstName} {name.lastName}</div>);
// }


// export default App3;

### 상태 비저장 컴포넌트

: React 상태 비저장 컴포넌트(stateless Component) 는 프롭을 argument로 받아 리액트 요소를 반환하는 순수 자바스크립트 함수에 해당합니다

```jsx
function HeaderText(props){
  return(
    <h1>
      {props.text}
    </h1>

  );
}

export default HeaderText
```

이상의 예제 컴포넌트는 순수 컴포넌트(Pure Component)라고 합니다.
동일한 입력값이 주어졌을 때 리턴ㄴ값이 동일한 컴포넌트를 의미합니다.
리액트는 순수 '함수 컴포넌트'의 성능을 최적화하는 React.memo()를 제공하는데 메모이제이션이라는 개념인데, 실습하면서 하겠습니다.

### 조건부 렌더링

: 조건문을 이용하여 조건이 true / false일 때 다른 UI를 렌더링할 수 있다.
(저희는 vanilla JS로 짰습니다 signin 페이지와 signup페이지로).
해당 기능은 일부 요소를 표시하거나 숨기고 인증을 처리하는 등의 작업에 이용 가능합니다.

```jsx
function MyComponent(props){
  const isLoggedIn = props.
}
```

// 동일한 구조라고 가정했을 때 경ㄹ국 if -else 구문이니까
// 우리는 위의 코드를 축약시킬 수 있을 겁니다. -> 삼항 연산자

삼항 연산자 적용 코드

```jsx
function MyComponent(props){
  const isLoggedin = props.isLoggedin;
  return(
    <>
    {isLoggedin ? <Logout /> : <Login />}
  )
}
```

## React Hook

: 훅(Hook)은 React 16.8부터 도입된 기능으로, 함수 컴포넌트에서
상태와 리액트의 다른 기능을 이용하는데 사용됩니다.

훅 이전에는 복잡한 컴포넌트 로직이 있는 경우 클래스 컴포넌트를 사용해야만
했었는데, 이를 통해 함수형 프로그래밍의 작성에 큰 도움을 주었습니다.

-> 배우기는 좀 어려웠습니다

- 리액트에서 훅을 이용하는데에 사용되는 규칙
1. 항상 리액트 함수 컴포넌트의 최상위 수준에서 훅을 호출해야함
2. 반복문, 조건문, 중첩 함수 안에서 훅을 호출해서는 안된다.
3. 훅 이름을 use로 시작하고, 그 뒤에 훅을 이용하는 목적이 따라온다

### useState

: 상태를 선언하는 데 이용하는 useState 함수 역시 훅에 해당합니다.

// import { useState } from "react";

// function Counter(){
//   const [count,setCount] = useState(0);

//   const handleClick = () => {
//     setCount((precount) => precount+1);
//     setCount((precount) => precount+1);
//     setCount((precount) => precount+1);
  
//   }
//   return(
//     <>
//       <p>카운터 : {count} </p>
//       <button onClick={handleClick}>증가</button>
//     </>
//   )
// }

// export default Counter